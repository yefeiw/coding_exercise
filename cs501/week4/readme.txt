####################  Week4 Notes #################
HW1: N-Queens
Basic Backtracking
Testcases:
1
2
3
4
5
6
7
8
9
Also I ahve printed the output for manual verification.
Output:
Accepted on first shot.

HW2: Factor Combinations
Backtracking/smarter conditions.
Note: I have a TLE solution using the most basic backtracking. It is not as effecient as divided target.
TestCases:
INT_MAX
INT_MAX-1
INT_MAX-2
1
2
3
4
5
6
7
8
9
Output:
TLE on the basic solution, Accepted after a while in thinking about how to optimize.

HW3 bombEnemy:
DP + dimension optimization
Note: It is very tricky that I think for this problem there is a (n2, n2) solution, and the recommended solution on leetcode is a (n, n3) solution.
TestCases: Relied on leetcode.
Output:
Accepted on first shot after thinking for some time.

HW4: GrayCode.
Binary operation + Divide and Conquer.
Note: the key point is undestanding the input. Once you get to know the input, it's easy.
TestCase:
1 2 3 4 5 6 7 8 9 0
Output:
Accpeted on first shot

HW5: BeautifulArrangement
Backtrack + Math
Note: Again understanding input is the key here.
TestCases: relied on leetcode
Output: Accepted after the first shot.

HW6: uglyNumber
DP with multiple state variables.
Test Cases:
1 2 3 4 5 6 7 8 9 0
Output: Accpeted after the first shot

HW7: subarraySUm
DP + Math (mod)
Test Cases:
Randomized
Output: accepted after the first shot

HW8: Arithmetic Slices
Counting
Note: Here how to construct solution would be very important. Once we know how to get the numbers this problem will be easy.
Test Cases: Leetcode
Output: Accpeted after some minor fixes.

HW9: HashMap
Note: I have read Java documentation for the API and then I need to seek help to write the following two parts:
1. How to construct the chaining more efficiently
2. How to expand and when to expand.

I would be glad to know how Jill has solved this problem.


